// Generated by CoffeeScript 1.3.3

/*
User: mmarinucci
Copyright Â© mename 2013 All rights reserved
Match
Every match is best out of 3 Rounds
*/


(function() {
  var Match, root;

  Match = (function() {

    Match.PHASES = [
      {
        id: 'init',
        simulataneous: true,
        "function": 'initPhase'
      }, {
        id: 'heroSelect',
        simulataneous: false,
        "function": 'heroSelectPhase'
      }, {
        id: 'roll',
        simulataneous: true,
        "function": 'rollPhase'
      }, {
        id: 'resolve',
        simulataneous: true,
        "function": 'resolvePhase'
      }
    ];

    function Match(deck) {
      var hero, name, playerHeroes, selectedHero;
      this.deck = deck;
      this.attacker = 1;
      this.isCpu = true;
      this.currentPhase = 0;
      this.rounds = new Array();
      this.results = new Array();
      this.currentRound = null;
      this.opponentRound = null;
      this.deck = Match.shuffle(deck);
      playerHeroes = (function() {
        var _ref, _results;
        _ref = Player.instance.heroes;
        _results = [];
        for (name in _ref) {
          hero = _ref[name];
          _results.push(name);
        }
        return _results;
      })();
      selectedHero = Player.getHeroByName(playerHeroes[Math.floor(Math.random() * playerHeroes.length)]);
      this.ready = [false, false];
      this.hero0 = new Hero((selectedHero != null ? selectedHero : selectedHero = this.deck[0]));
      this.hero1 = new Hero(this.deck[1]);
    }

    Match.prototype.nextRound = function() {
      this.opponentRound = new CpuRound(this, this.hero1, this.attacker ^ 1);
      this.currentRound = new PlayerRound(this, this.hero0, this.attacker);
      return this.nextPhase();
    };

    Match.prototype.nextPhase = function() {
      var phase;
      this.currentPhase++;
      this.ready = [false, false];
      if (this.currentPhase >= Match.PHASES.length) {
        this.endRound();
      } else {
        console.log("About to process phase " + Match.PHASES[this.currentPhase].id);
        phase = Match.PHASES[this.currentPhase];
        if (phase.simulataneous) {
          this.currentRound[phase["function"]]();
          return this.opponentRound[phase["function"]]();
        } else {
          this.currentRound[phase["function"]]();
          return this.opponentRound.holdPhase();
        }
      }
    };

    Match.prototype.roundResult = function() {
      var currentDmg, opponentDmg, result;
      currentDmg = this.currentRound.resolveHeroDamage();
      opponentDmg = this.opponentRound.resolveHeroDamage();
      return result = {
        roundNumber: this.rounds.length,
        summary: "" + this.currentRound.hero.name + " (" + currentDmg + ") VS " + this.opponentRound.hero.name + " (" + opponentDmg + ")",
        outcome: (currentDmg > opponentDmg ? "Win" : (opponentDmg > currentDmg ? "Lose" : "Tie")),
        currentHero: this.currentRound.hero.picture,
        currentRoll: this.currentRound.roll,
        currentDmg: currentDmg,
        opponentHero: this.opponentRound.hero.picture,
        opponentRoll: this.opponentRound.roll,
        opponentDmg: opponentDmg
      };
    };

    Match.prototype.endRound = function() {
      var currentDmg, currentId, currentVictories, opponentDmg, opponentId, opponentVictories, resultsMode, roundReset, winner;
      currentDmg = this.currentRound.resolveHeroDamage();
      opponentDmg = this.opponentRound.resolveHeroDamage();
      if (currentDmg > opponentDmg) {
        this.rounds.push(this.currentRound.hero.name);
      } else if (opponentDmg > currentDmg) {
        this.rounds.push(this.opponentRound.hero.name);
      } else if (currentDmg === opponentDmg) {
        this.rounds.push('tie');
      }
      currentId = this.currentRound.hero.name;
      opponentId = this.opponentRound.hero.name;
      currentVictories = $.grep(this.rounds, function(winnerId) {
        return winnerId === currentId;
      });
      opponentVictories = $.grep(this.rounds, function(winnerId) {
        return winnerId === opponentId;
      });
      winner = false;
      if ((currentVictories - opponentVictories) >= 2) {
        console.log('player won');
        winner = true;
      }
      if ((opponentVictories - currentVictories) >= 2) {
        console.log('opponent won');
        winner = true;
      }
      if (this.rounds.length === 3 && !winner) {
        console.log('tie!');
        winner = true;
      }
      this.results.push(this.roundResult());
      if (!winner) {
        this.currentPhase = 0;
        roundReset = new Event('round.reset');
        window.dispatchEvent(roundReset);
        return this.nextRound();
      } else {
        GameManager.instance.popGameMode();
        resultsMode = new ResultsMode();
        GameManager.instance.pushGameMode(resultsMode);
        return resultsMode.init(this.results);
      }
    };

    Match.prototype.phaseCompleted = function(round) {
      var phase;
      console.log('phase ' + Match.PHASES[this.currentPhase].id + ' completed by round attacker: ' + round.isAttacker());
      this.ready[round.attacker] = true;
      phase = Match.PHASES[this.currentPhase];
      if (this.ready[0] && this.ready[1]) {
        return this.nextPhase();
      } else if ((round.isAttacker()) && !phase.simulataneous) {
        round.holdPhase();
        return this.opponentRound[phase["function"]]();
      }
    };

    Match.shuffle = function(o) {
      var i, j, x;
      j = void 0;
      x = void 0;
      i = o.length;
      while (i) {
        j = Math.floor(Math.random() * i);
        x = o[--i];
        o[i] = o[j];
        o[j] = x;
      }
      return o;
    };

    return Match;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Match = Match;

}).call(this);
