// Generated by CoffeeScript 1.3.3

/*
User: mmarinucci
Copyright Â© mename 2013 All rights reserved
Round
*/


(function() {
  var Round, root,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Round = (function() {

    Round.DIE = ['r', 'r', 'y', 'b', 'a', 'a'];

    Round.DICE = 6;

    Round.PHASES = {
      'init': 'init',
      'heroSelect': 'heroSelect',
      'roll': 'roll',
      'resolve': 'resolve'
    };

    function Round(match, hero, attacker) {
      this.match = match;
      this.hero = hero;
      this.attacker = attacker;
      this.nextRoll = __bind(this.nextRoll, this);

      this.totalDamage = 0;
      this.roll = new Array();
      this.hold = [false, false, false, false, false, false];
      this.reroll = 0;
      this.currentPhase = Round.PHASES.init;
    }

    Round.prototype.heroSelectPhase = function() {};

    Round.prototype.holdPhase = function() {};

    Round.prototype.rollPhase = function() {};

    Round.prototype.resolvePhase = function() {};

    Round.prototype.isAttacker = function() {
      return this.attacker === 1;
    };

    Round.prototype.canReroll = function() {
      return this.reroll < 3;
    };

    Round.prototype.nextRoll = function() {
      var rollEvent, roundReady;
      if (this.canReroll()) {
        rollEvent = new Event('round.roll');
        window.dispatchEvent(rollEvent);
        this.reroll++;
        if (this.reroll === 3) {
          roundReady = new Event('round.ready');
          return window.dispatchEvent(roundReady);
        }
      } else {
        throw "Round - Reroll max exceeded";
      }
    };

    Round.prototype.resolveHeroDamage = function() {
      var die, effect, effects, skillLevel, totalDamage, _i, _j, _k, _len, _len1, _ref, _ref1;
      totalDamage = 0;
      for (skillLevel = _i = 0, _ref = this.hero.skills.length; 0 <= _ref ? _i <= _ref : _i >= _ref; skillLevel = 0 <= _ref ? ++_i : --_i) {
        effects = this.hero.activateSkill(skillLevel, this.roll);
        for (_j = 0, _len = effects.length; _j < _len; _j++) {
          effect = effects[_j];
          totalDamage += Number(effect.split(':')[1]);
        }
      }
      _ref1 = this.roll;
      for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
        die = _ref1[_k];
        if (die === 'a') {
          totalDamage += this.hero.atk;
        }
      }
      return totalDamage;
    };

    return Round;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Round = Round;

}).call(this);
